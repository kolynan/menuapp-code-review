// ======================================================
// pages/x.jsx â€” PUBLIC MENU with i18n + Channels Visibility + Gating
// UPDATED: Simplified Hall logic (TASK-260123-01b)
// FIXED: P0-1..P0-7 security and functionality fixes
// UPDATED: TASK-260127-01 - session restore, UI cleanup
// PATCHED: 2026-01-28 - P0-1, P0-2, P0-2b, P1-1..P1-4
// PATCHED: 2026-02-01 - FIX-260131-07 FINAL - guest safeguard in submit
// PATCHED: 2026-02-01 - TASK-260201-01 - Hall StickyBar always visible
// ======================================================

import React, { useEffect, useMemo, useRef, useState } from "react";
import { useLocation } from "react-router-dom";
import { useQuery, useQueryClient } from "@tanstack/react-query";
import { base44 } from "@/api/base44Client";
import { useI18n } from "@/components/i18n";
import { toast } from "sonner"; // P0-6: sonner instead of custom toast

import {
  AlertCircle,
  ArrowLeft,
  Bell,
  CheckCircle2,
  ChevronDown,
  ChevronUp,
  Image as ImageIcon,
  Loader2,
  MapPin,
  Minus,
  Plus,
  ShoppingCart,
  X as XIcon,
  Globe,
  Phone,
  Mail,
  MessageCircle,
  Link as LinkIcon,
  Store,
  Package,
  Truck,
  Users,
} from "lucide-react";

import {
  getOrCreateSession,
  addGuestToSession,
  findGuestByDevice,
  getSessionGuests,
  getSessionOrders,
  getDeviceId,
  getGuestDisplayName,
  getNextOrderNumber,
  isSessionExpired,
} from "@/components/sessionHelpers";

import {
  normalizeMode,
  isDishEnabledForMode,
  sortCategoriesStable,
  sortDishesStable,
  buildDishesByCategory,
  getVisibleCategoryIds,
} from "@/components/menuChannelLogic";

import { Card, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";

// TASK-260203-01: Drawer for cart
import { Drawer, DrawerContent, DrawerHeader, DrawerTitle } from "@/components/ui/drawer";

import Rating from "@/components/Rating";
import PublicMenuHeader from "@/components/publicMenu/PublicMenuHeader";
import HelpFab from "@/components/publicMenu/HelpFab";
import HelpModal from "@/components/publicMenu/HelpModal";
import ReviewDialog from "@/components/publicMenu/ReviewDialog";
import StickyCartBar from "@/components/publicMenu/StickyCartBar";
import MenuView from "@/components/publicMenu/MenuView";
import CartView from "@/components/publicMenu/CartView";
import RedirectBanner from "@/components/publicMenu/refactor/RedirectBanner";
import DishReviewsModal from "@/components/publicMenu/DishReviewsModal";
import ModeTabs from "@/components/publicMenu/refactor/ModeTabs";
import CategoryChips from "@/components/publicMenu/refactor/CategoryChips";
import HallVerifyBlock from "@/components/publicMenu/refactor/HallVerifyBlock";
import ErrorState from "@/components/publicMenu/refactor/ErrorState";
import EmptyMenuState from "@/components/publicMenu/refactor/EmptyMenuState";
import CheckoutView from "@/components/publicMenu/views/CheckoutView";
import { useCurrency } from "@/components/publicMenu/refactor/hooks/useCurrency";
import { useHallTable } from "@/components/publicMenu/refactor/hooks/useHallTable";
import { useHelpRequests } from "@/components/publicMenu/refactor/hooks/useHelpRequests";
import { useLoyalty } from "@/components/publicMenu/refactor/hooks/useLoyalty";
import { useReviews } from "@/components/publicMenu/refactor/hooks/useReviews";
import { useTableSession } from "@/components/publicMenu/refactor/hooks/useTableSession";

// ============================================================
// CONSTANTS & HELPERS
// ============================================================

const IS_ARCHIVED_TAG = ":::archived:::";

const isDishArchived = (dish) =>
  !!dish?.description && dish.description.includes(IS_ARCHIVED_TAG);

const getCleanDescription = (desc) =>
  desc ? desc.replace(IS_ARCHIVED_TAG, "").trim() : "";

const looksLikePartnerId = (value) =>
  /^[0-9a-f]{24}$/i.test(String(value || "").trim());

// P0-5: Rate limit detection
const isRateLimitError = (err) => {
  const msg = (err?.message || "").toLowerCase();
  return msg.includes("rate limit") || msg.includes("429");
};

const shouldRetry = (count, err) => !isRateLimitError(err) && count < 2;

// P1-1: XSS protection for contact URLs
const isSafeUrl = (url) => {
  if (!url) return false;
  const allowed = ['http:', 'https:', 'tel:', 'mailto:', 'whatsapp:'];
  try {
    const parsed = new URL(url, window.location.origin);
    return allowed.includes(parsed.protocol);
  } catch {
    return false;
  }
};

function getContactIcon(type) {
  const map = {
    phone: Phone,
    whatsapp: MessageCircle,
    instagram: LinkIcon,
    facebook: LinkIcon,
    tiktok: LinkIcon,
    website: Globe,
    email: Mail,
    map: MapPin,
    custom: LinkIcon,
  };
  return map[type] || LinkIcon;
}

// Cart persistence helpers
const saveCartToStorage = (partnerId, cartData) => {
  if (!partnerId) return;
  try {
    const key = `menuapp_cart_${partnerId}`;
    localStorage.setItem(key, JSON.stringify(cartData));
  } catch (e) {
    console.error("Failed to save cart", e);
  }
};

const getCartFromStorage = (partnerId) => {
  if (!partnerId) return null;
  try {
    const key = `menuapp_cart_${partnerId}`;
    const raw = localStorage.getItem(key);
    if (!raw) return null;
    const data = JSON.parse(raw);
    return Array.isArray(data) ? data : null;
  } catch {
    return null;
  }
};

const clearCartStorage = (partnerId) => {
  if (!partnerId) return;
  try {
    const key = `menuapp_cart_${partnerId}`;
    localStorage.removeItem(key);
  } catch {}
};

/* ============================================================
   CHANNELS VISIBILITY LOGIC (per LOCKED spec)
   ============================================================ */

function isDishAvailableForGuest(dish, mode, categoriesMap) {
  if (!dish) return false;
  if (isDishArchived(dish)) return false;
  if (dish[`enabled_${mode}`] === false) return false;
  if (!dish.name?.trim()) return false;
  if (dish.price == null || dish.price < 0) return false;

  const categoryId = dish.category;
  if (categoryId && categoriesMap) {
    const category = categoriesMap.get(String(categoryId));
    if (category && category.is_active === false) return false;
  }
  return true;
}

function useGuestChannels(partner, dishes, categories) {
  return useMemo(() => {
    const isConfigured = partner?.channels_configured_at != null;
    const categoriesMap = new Map((categories || []).map((c) => [String(c.id), c]));

    const hasDishesForMode = (mode) => {
      return (dishes || []).some((dish) => isDishAvailableForGuest(dish, mode, categoriesMap));
    };

    const hallPublished = partner?.channels_hall_enabled !== false;
    const pickupPublished = partner?.channels_pickup_enabled !== false;
    const deliveryPublished = partner?.channels_delivery_enabled !== false;

    const hallHasContent = hasDishesForMode("hall");
    const pickupHasContent = hasDishesForMode("pickup");
    const deliveryHasContent = hasDishesForMode("delivery");

    return {
      hall: {
        visible: hallPublished,
        available: hallPublished && hallHasContent,
        hasContent: hallHasContent,
        disabled: hallPublished && !hallHasContent,
      },
      pickup: {
        visible: pickupPublished && isConfigured,
        available: pickupPublished && isConfigured && pickupHasContent,
        hasContent: pickupHasContent,
        disabled: pickupPublished && isConfigured && !pickupHasContent,
      },
      delivery: {
        visible: deliveryPublished && isConfigured,
        available: deliveryPublished && isConfigured && deliveryHasContent,
        hasContent: deliveryHasContent,
        disabled: deliveryPublished && isConfigured && !deliveryHasContent,
      },
      isConfigured,
      hasAnyContent: hallHasContent || pickupHasContent || deliveryHasContent,
    };
  }, [partner, dishes, categories]);
}

const SCROLL_SPY_OFFSET_PX = 100;
const MANUAL_SCROLL_LOCK_MS = 800;
const BILL_COOLDOWN_MS = 5 * 60 * 1000; // 5 minutes

// Bill request cooldown helpers
const getBillCooldownKey = (tableId) => `menuapp_bill_requested_${tableId}`;

const isBillOnCooldown = (tableId) => {
  const key = getBillCooldownKey(tableId);
  const timestamp = localStorage.getItem(key);
  if (!timestamp) return false;
  return Date.now() - parseInt(timestamp, 10) < BILL_COOLDOWN_MS;
};

const setBillCooldownStorage = (tableId) => {
  const key = getBillCooldownKey(tableId);
  localStorage.setItem(key, String(Date.now()));
};

/**
 * ÐÐ°Ñ…Ð¾Ð´Ð¸Ñ‚ ÑÑ‚Ð°Ñ€Ñ‚Ð¾Ð²Ñ‹Ð¹ ÑÑ‚Ð°Ð¿ Ð´Ð»Ñ Ð·Ð°ÐºÐ°Ð·Ð°
 */
function getStartStage(stages, orderType) {
  if (!stages?.length) return null;
  
  const channelStages = stages.filter(stage => {
    switch (orderType) {
      case 'hall': return stage.enabled_hall !== false;
      case 'pickup': return stage.enabled_pickup !== false;
      case 'delivery': return stage.enabled_delivery !== false;
      default: return true;
    }
  });
  
  const startStage = channelStages.find(s => s.internal_code === 'start');
  if (startStage) return startStage;
  
  const sorted = [...channelStages].sort((a, b) => (a.sort_order || 0) - (b.sort_order || 0));
  return sorted[0] || null;
}

/**
 * Order Status Badge component (TASK-260126-01)
 */
function OrderStatusBadge({ status, stageId, stages, t }) {
  // Map internal_code to translated labels (don't show raw stage.name to guests)
  const STAGE_LABELS = {
    start: t('status.new'),
    middle: t('status.cooking'),
    finish: t('status.ready'),
  };
  
  // Normalize stageId (can be string, object with id, etc)
  const stageIdNorm = stageId && typeof stageId === 'object' 
    ? (stageId.id ?? stageId._id ?? null) 
    : stageId;
  
  // If has stage_id - use OrderStage config but translated label
  if (stageIdNorm && stages?.length) {
    const stage = stages.find(s => String(s.id) === String(stageIdNorm));
    if (stage) {
      const icon = stage.internal_code === 'finish' ? 'âœ…' : 
                   stage.internal_code === 'start' ? 'ðŸ”µ' : 'ðŸŸ ';
      const label = STAGE_LABELS[stage.internal_code] || t('status.new');
      const color = stage.color || '#64748b';
      return (
        <span 
          className="inline-flex items-center gap-1 text-xs px-2 py-1 rounded-full"
          style={{ backgroundColor: `${color}20`, color }}
        >
          {icon} {label}
        </span>
      );
    }
  }
  
  // Fallback to status
  const STATUS_CONFIG = {
    new: { icon: 'ðŸ”µ', label: t('status.new'), bg: 'bg-blue-100', color: 'text-blue-700' },
    accepted: { icon: 'ðŸ”µ', label: t('status.accepted'), bg: 'bg-blue-100', color: 'text-blue-700' },
    in_progress: { icon: 'ðŸŸ ', label: t('status.cooking'), bg: 'bg-orange-100', color: 'text-orange-700' },
    ready: { icon: 'âœ…', label: t('status.ready'), bg: 'bg-green-100', color: 'text-green-700' },
    served: { icon: 'âœ…', label: t('status.served'), bg: 'bg-green-100', color: 'text-green-700' },
  };
  
  const config = STATUS_CONFIG[status] || STATUS_CONFIG.new;
  
  return (
    <span className={`inline-flex items-center gap-1 text-xs px-2 py-1 rounded-full ${config.bg} ${config.color}`}>
      {config.icon} {config.label}
    </span>
  );
}

/* ============================================================
   TABLE CODE VERIFICATION HELPERS (simplified)
   P0-3: Only use Table.code for verification
   ============================================================ */

// Extract digits only from any value
const digits = (v) => String(v || "").replace(/\D/g, "");

// Normalize link fields from Base44 (CODE-026)
function getLinkId(field) {
  if (field == null) return null;
  if (typeof field === "string" || typeof field === "number") return String(field);
  if (typeof field === "object") {
    const v = field.id ?? field._id ?? field.value ?? null;
    if (typeof v === "string" || typeof v === "number") return String(v);
    if (v && typeof v === "object") {
      const vv = v.id ?? v._id ?? null;
      if (typeof vv === "string" || typeof vv === "number") return String(vv);
    }
  }
  return null;
}

// Helper: format order creation time (handles created_at or created_date)
function formatOrderTime(order) {
  const ts = order?.created_at || order?.created_date || order?.createdAt || null;
  if (!ts) return "";
  const d = new Date(ts);
  if (Number.isNaN(d.getTime())) return "";
  return d.toLocaleTimeString("ru-RU", { hour: "2-digit", minute: "2-digit" });
}

export default function X() {
  const { lang, setLang, t } = useI18n();
  const location = useLocation();
  const queryClient = useQueryClient();

  const searchParams = useMemo(
    () => new URLSearchParams(location.search),
    [location.search]
  );

  // partner required
  const partnerParamRaw = (searchParams.get("partner") || searchParams.get("p") || "").trim();

  // lang param from URL
  const langParam = (searchParams.get("lang") || "").trim().toUpperCase();

  // UI state
  const [orderMode, setOrderMode] = useState(() => {
    const modeParam = new URLSearchParams(location.search).get("mode");
    return normalizeMode(modeParam);
  });

  const [view, setView] = useState("menu"); /* menu | checkout */
  
  // TASK-260203-01: Drawer state
  const [drawerMode, setDrawerMode] = useState(null); // 'cart' | null
  
  const [activeCategoryKey, setActiveCategoryKey] = useState("all");
  const [cart, setCart] = useState([]); // { dishId, name, price, quantity }
  const cartRestoredRef = useRef(false);

  // Mobile breakpoint detection
  const [isMobile, setIsMobile] = useState(() => {
    if (typeof window === 'undefined') return false;
    return window.matchMedia("(max-width: 767px)").matches;
  });

  // Mobile layout preference (tile | list)
  const [mobileLayout, setMobileLayout] = useState('tile');

  // Redirect banner state
  const [redirectBanner, setRedirectBanner] = useState(null);

  // Dish reviews modal state
  const [selectedDishId, setSelectedDishId] = useState(null);

  // Form
  const [clientName, setClientName] = useState("");
  const [clientPhone, setClientPhone] = useState("");
  const [deliveryAddress, setDeliveryAddress] = useState("");
  const [comment, setComment] = useState("");
  const [errors, setErrors] = useState({});

  const [isSubmitting, setIsSubmitting] = useState(false);
  const [submitError, setSubmitError] = useState(null);

  // Guest code (4-digit code for showing to waiter)
  const [guestCode, setGuestCode] = useState(null);

  // Hall UI state (not in session hook)
  const [splitType, setSplitType] = useState('single'); // 'single' | 'all'
  const [otherGuestsExpanded, setOtherGuestsExpanded] = useState(false);
  const [guestNameInput, setGuestNameInput] = useState('');
  const [isEditingName, setIsEditingName] = useState(false);

  // Bill request state
  const [billRequested, setBillRequested] = useState(false);
  const [billCooldown, setBillCooldown] = useState(false);

  // Rating flow state (TASK-260130-09)
  const [hasRatedInSession, setHasRatedInSession] = useState(false);
  const [ratingSavingByItemId, setRatingSavingByItemId] = useState({});

  // Partner fetch (id or slug) - MUST BE FIRST before any partner dependencies
  const { data: partner, isLoading: loadingPartner } = useQuery({
    queryKey: ["publicPartner", partnerParamRaw],
    enabled: !!partnerParamRaw,
    retry: shouldRetry,
    queryFn: async () => {
      const p = partnerParamRaw;
      if (!p) return null;

      const byIdFirst = looksLikePartnerId(p);

      try {
        const res = await base44.entities.Partner.filter(byIdFirst ? { id: p } : { slug: p });
        if (res?.[0]) return res[0];
      } catch (e) {
        console.warn("Partner primary lookup failed", e);
      }

      try {
        const res2 = await base44.entities.Partner.filter(byIdFirst ? { slug: p } : { id: p });
        return res2?.[0] || null;
      } catch (e) {
        console.warn("Partner fallback lookup failed", e);
        return null;
      }
    },
  });

  // Breakpoint listener
  useEffect(() => {
    const mediaQuery = window.matchMedia("(max-width: 767px)");
    
    const handleChange = (e) => {
      setIsMobile(e.matches);
    };
    
    mediaQuery.addEventListener('change', handleChange);
    
    return () => {
      mediaQuery.removeEventListener('change', handleChange);
    };
  }, []);

  // Load mobile layout preference from localStorage
  useEffect(() => {
    if (!partner) return;
    
    const partnerKey = partner.id || partner._id || partner.slug || partner.code;
    if (!partnerKey) return;
    
    try {
      const storageKey = `menuMobileLayout:${partnerKey}`;
      const saved = localStorage.getItem(storageKey);
      
      if (saved === 'tile' || saved === 'list') {
        setMobileLayout(saved);
      } else {
        // Default based on partner setting
        const defaultLayout = (partner.menu_grid_mobile ?? 2) === 1 ? 'list' : 'tile';
        setMobileLayout(defaultLayout);
      }
    } catch (e) {
      console.warn('Failed to load mobile layout preference', e);
    }
  }, [partner?.id, partner?._id, partner?.slug, partner?.code]);

  // Save mobile layout preference to localStorage
  const handleSetMobileLayout = (layout) => {
    setMobileLayout(layout);
    
    if (!partner) return;
    
    const partnerKey = partner.id || partner._id || partner.slug || partner.code;
    if (!partnerKey) return;
    
    try {
      const storageKey = `menuMobileLayout:${partnerKey}`;
      localStorage.setItem(storageKey, layout);
    } catch (e) {
      console.warn('Failed to save mobile layout preference', e);
    }
  };

  // Save cart to localStorage on every change
  useEffect(() => {
    if (!partner?.id) return;
    saveCartToStorage(partner.id, cart);
  }, [cart, partner?.id]);

  // Restore cart from localStorage on page load (once)
  useEffect(() => {
    if (cartRestoredRef.current) return;
    if (!partner?.id) return;
    
    const savedCart = getCartFromStorage(partner.id);
    if (savedCart && savedCart.length > 0 && cart.length === 0) {
      setCart(savedCart);
    }
    cartRestoredRef.current = true;
  }, [partner?.id]);

  // Scroll refs
  const sectionRefs = useRef({});
  const chipRefs = useRef({});
  const listTopRef = useRef(null);
  const isManualScroll = useRef(false);
  const submitLockRef = useRef(false); // CODE-024: protect from double-tap

  // Language change handler (updates URL)
  const handleLangChange = (newLang) => {
    setLang(newLang);
    const url = new URL(window.location.href);
    url.searchParams.set("lang", newLang);
    window.history.replaceState({}, "", url.toString());
  };

  // Contact link click handler (SEC-021: XSS protection + noopener)
  const handleContactClick = (link) => {
    const url = String(link.url || "");
    if (!isSafeUrl(url)) {
      toast.error(t('error.invalid_link'), { id: 'mm1' });
      return;
    }
    if (url.startsWith("tel:") || url.startsWith("mailto:")) {
      window.location.href = url;
    } else {
      window.open(url, "_blank", "noopener,noreferrer");
    }
  };

  // Hall table verification hook
  const {
    tableCodeParam,
    resolvedTable,
    isHallMode,
    tableCodeInput,
    setTableCodeInput,
    isVerifyingCode,
    verifiedByCode,
    verifiedTableId,
    verifiedTable,
    codeVerificationError,
    verifyTableCode,
  } = useHallTable({ partner, location, orderMode, t });

  // Helper for saving table selection (used by help requests and other features)
  const saveTableSelection = (partnerId, tableId) => {
    if (!partnerId || !tableId) return;
    try {
      const key = `menuApp_table_${partnerId}`;
      localStorage.setItem(
        key,
        JSON.stringify({ partnerId, tableId, timestamp: Date.now() })
      );
    } catch (e) {
      console.error("Failed to save table", e);
    }
  };

  // Hall settings (simplified - only guest code)
  const hallGuestCodeEnabled = partner?.hall_guest_code_enabled === true;

  // Set language from URL param or partner default
  useEffect(() => {
    if (!partner) return;
    
    const partnerDefault = partner.default_language || "RU";
    const enabledLangs = Array.isArray(partner.enabled_languages) && partner.enabled_languages.length > 0
      ? partner.enabled_languages
      : [partnerDefault];
    
    if (langParam && enabledLangs.includes(langParam)) {
      if (lang !== langParam) setLang(langParam);
    } else if (!enabledLangs.includes(lang)) {
      setLang(partnerDefault);
    }
  }, [partner?.id, partner?.default_language, langParam]);
  // P0-7: Removed hallTableSelectEnabled - no dropdown

  // P0-1: Table verified ONLY when actually resolved or verified by code input
  // Removed hasTableInUrl from condition - URL param alone doesn't mean verified
  const isTableVerified = isHallMode && (!!resolvedTable?.id || verifiedByCode);

  // P0-7: Removed activeTables query - no dropdown needed

  // P0-2: currentTableId only from resolved table or code verification
  const currentTableId = resolvedTable?.id || verifiedTableId || null;
  
  // Current table object for display (from QR resolve or code verify)
  const currentTable = resolvedTable || verifiedTable || null;

  // Help / ServiceRequest hook
  const {
    isHelpModalOpen,
    setIsHelpModalOpen,
    selectedHelpType,
    helpComment,
    setHelpComment,
    isSendingHelp,
    helpSubmitError,
    fabSuccess,
    hasActiveRequest,
    handleOpenHelpModal,
    handlePresetSelect,
    submitHelpRequest,
  } = useHelpRequests({ partner, currentTableId, t, toast, isRateLimitError, saveTableSelection });

  // OrderStages for the partner (for stage_id assignment)
  const { data: orderStages = [] } = useQuery({
    queryKey: ["orderStages", partner?.id],
    enabled: !!partner?.id,
    retry: shouldRetry,
    queryFn: () => base44.entities.OrderStage.filter({ 
      partner: partner.id, 
      is_active: true 
    }),
    staleTime: 5 * 60 * 1000,
  });

  // P0-4: Menu data - filter by partner on server side
  const { data: allDishes, isLoading: loadingDishes, error: dishesError } = useQuery({
    queryKey: ["dishes", partner?.id],
    enabled: !!partner?.id,
    retry: shouldRetry,
    queryFn: () => base44.entities.Dish.filter({ partner: partner.id }),
  });

  const { data: allCategories, error: categoriesError } = useQuery({
    queryKey: ["categories", partner?.id],
    enabled: !!partner?.id,
    retry: shouldRetry,
    queryFn: () => base44.entities.Category.filter({ partner: partner.id }),
  });

  // P0-4: Warning if limit reached
  useEffect(() => {
    if (allDishes?.length === 100) {
      console.warn("Dish limit reached (100), menu may be incomplete");
    }
    if (allCategories?.length === 100) {
      console.warn("Category limit reached (100), menu may be incomplete");
    }
  }, [allDishes?.length, allCategories?.length]);

  const { data: partnerContactsRaw = [] } = useQuery({
    queryKey: ["partnerContacts", partner?.id],
    enabled: !!partner?.id,
    retry: shouldRetry,
    queryFn: () => base44.entities.PartnerContacts.filter({ partner: partner.id }),
    initialData: [],
  });

  const { data: contactLinksRaw = [] } = useQuery({
    queryKey: ["partnerContactLinks", partner?.id],
    enabled: !!partner?.id,
    retry: shouldRetry,
    queryFn: () => base44.entities.PartnerContactLink.filter({ partner: partner.id }),
    initialData: [],
  });

  // Fetch translations
  const { data: categoryTranslations } = useQuery({
    queryKey: ["categoryTranslations", partner?.id, lang],
    enabled: !!partner?.id,
    retry: shouldRetry,
    queryFn: async () => {
      try {
        return await base44.entities.CategoryTranslation.filter({
          partner: partner.id,
          lang: lang
        });
      } catch (e) {
        console.warn("Failed to fetch category translations", e);
        return [];
      }
    },
    initialData: []
  });

  const { data: dishTranslations } = useQuery({
    queryKey: ["dishTranslations", partner?.id, lang],
    enabled: !!partner?.id,
    retry: shouldRetry,
    queryFn: async () => {
      try {
        return await base44.entities.DishTranslation.filter({
          partner: partner.id,
          lang: lang
        });
      } catch (e) {
        console.warn("Failed to fetch dish translations", e);
        return [];
      }
    },
    initialData: []
  });

  // Dish ratings/reviews
  const showReviews = partner?.show_dish_reviews === true;
  const partnerId = partner?.id || partner?._id;
  
  const { data: partnerFeedbacks = [] } = useQuery({
    queryKey: ["dishFeedbacksRecent", partnerId],
    queryFn: () => base44.entities.DishFeedback.filter({ partner: partnerId }, "-created_date", 100),
    enabled: showReviews && !!partnerId,
    retry: shouldRetry,
    staleTime: 5 * 60 * 1000,
  });

  // Build translation lookup maps
  const categoryTransMap = useMemo(() => {
    const map = {};
    (categoryTranslations || []).forEach(tr => {
      map[tr.category] = tr.name;
    });
    return map;
  }, [categoryTranslations]);

  const dishTransMap = useMemo(() => {
    const map = {};
    (dishTranslations || []).forEach(tr => {
      map[tr.dish] = {
        name: tr.name,
        description: tr.description
      };
    });
    return map;
  }, [dishTranslations]);

  // Aggregate dish ratings
  const dishRatings = useMemo(() => {
    if (!showReviews || !partnerFeedbacks?.length) return {};
    const tmp = {}; // { [dishId]: { sum, count } }

    for (const f of partnerFeedbacks) {
      const dishId = typeof f.dish === "object" ? f.dish?.id : f.dish;
      const rating = Number(f.rating);
      if (!dishId || !rating) continue;

      if (!tmp[dishId]) tmp[dishId] = { sum: 0, count: 0 };
      tmp[dishId].sum += rating;
      tmp[dishId].count += 1;
    }

    const out = {};
    for (const dishId of Object.keys(tmp)) {
      out[dishId] = {
        avg: tmp[dishId].sum / tmp[dishId].count,
        count: tmp[dishId].count,
      };
    }
    return out;
  }, [showReviews, partnerFeedbacks]);

  // Load reviews for selected dish (modal)
  const { data: selectedDishReviews = [], isLoading: loadingDishReviews } = useQuery({
    queryKey: ["dishReviews", partnerId, selectedDishId],
    queryFn: () => base44.entities.DishFeedback.filter(
      { partner: partnerId, dish: selectedDishId },
      "-created_date",
      20
    ),
    enabled: showReviews && !!partnerId && !!selectedDishId,
    retry: shouldRetry,
    staleTime: 5 * 60 * 1000,
  });

  // Helper functions to get translated content with fallback
  const getCategoryName = (category) => {
    return categoryTransMap[category.id] || category.name;
  };

  const getDishName = (dish) => {
    return dishTransMap[dish.id]?.name || dish.name;
  };

  const getDishDescription = (dish) => {
    const translated = dishTransMap[dish.id]?.description;
    if (translated) return translated;
    return getCleanDescription(dish.description);
  };

  // P1-8: Sync cart names when language changes
  useEffect(() => {
    if (!cart.length || !dishTransMap || Object.keys(dishTransMap).length === 0) return;
    
    setCart(prev => prev.map(item => {
      const translated = dishTransMap[item.dishId];
      if (translated?.name && translated.name !== item.name) {
        return { ...item, name: translated.name };
      }
      return item;
    }));
  }, [lang, dishTransMap]);

  const partnerContacts = partnerContactsRaw?.[0] || null;
  const viewMode = partner?.contacts_view_mode || partnerContacts?.view_mode || "full";

  const activeContactLinks = useMemo(() => {
    return contactLinksRaw
      .filter((link) => link.is_active !== false)
      .sort((a, b) => {
        const oa = a?.sort_order;
        const ob = b?.sort_order;
        if (oa == null && ob == null) return 0;
        if (oa == null) return 1;
        if (ob == null) return -1;
        return oa - ob;
      });
  }, [contactLinksRaw]);

  // Enabled languages for switcher
  const enabledLanguages = useMemo(() => {
    const partnerDefault = partner?.default_language || "RU";
    const enabled = partner?.enabled_languages;
    if (Array.isArray(enabled) && enabled.length > 0) {
      return enabled;
    }
    return [partnerDefault];
  }, [partner?.default_language, partner?.enabled_languages]);

  // Currency hook
  const {
    activeCurrency,
    enabledCurrencies,
    defaultCurrency,
    currencyRates,
    formatPrice,
    handleCurrencyChange,
    CURRENCY_SYMBOLS,
  } = useCurrency({ partner, location });

  // P0-4: Simplified - server already filters by partner
  const dishesForPartner = useMemo(() => {
    if (!allDishes) return [];
    return allDishes.filter((d) => !isDishArchived(d));
  }, [allDishes]);

  const categoriesForPartner = useMemo(() => {
    return allCategories || [];
  }, [allCategories]);

  // Get dish name for modal (moved here after dishesForPartner is declared)
  const selectedDish = useMemo(() => {
    if (!selectedDishId) return null;
    return dishesForPartner.find(d => d.id === selectedDishId);
  }, [selectedDishId, dishesForPartner]);

  // Channel visibility
  const channels = useGuestChannels(partner, dishesForPartner, categoriesForPartner);

  // Get visible mode tabs
  const visibleModeTabs = useMemo(() => {
    const tabs = [];
    
    if (channels.hall.visible) {
      tabs.push({
        id: "hall",
        label: t('mode.hall'),
        Icon: Store,
        available: channels.hall.available,
        disabled: channels.hall.disabled,
      });
    }
    
    if (channels.pickup.visible) {
      tabs.push({
        id: "pickup",
        label: t('mode.pickup'),
        Icon: Package,
        available: channels.pickup.available,
        disabled: channels.pickup.disabled,
      });
    }
    
    if (channels.delivery.visible) {
      tabs.push({
        id: "delivery",
        label: t('mode.delivery'),
        Icon: Truck,
        available: channels.delivery.available,
        disabled: channels.delivery.disabled,
      });
    }
    
    return tabs;
  }, [channels, t]);

  // Check if current mode is valid and redirect if needed
  useEffect(() => {
    if (!partner || loadingDishes) return;

    const currentModeChannel = channels[orderMode];
    
    if (!currentModeChannel?.visible || !currentModeChannel?.available) {
      const firstAvailable = visibleModeTabs.find((tab) => tab.available);
      
      if (firstAvailable && firstAvailable.id !== orderMode) {
        const originalMode = orderMode;
        setOrderMode(firstAvailable.id);
        
        const url = new URL(window.location.href);
        url.searchParams.set("mode", firstAvailable.id);
        window.history.replaceState({}, "", url.toString());
        
        const modeLabels = {
          hall: t('mode.hall'),
          pickup: t('mode.pickup'),
          delivery: t('mode.delivery'),
        };
        setRedirectBanner({
          originalMode: modeLabels[originalMode] || originalMode,
          newMode: modeLabels[firstAvailable.id] || firstAvailable.id,
        });
        
        setTimeout(() => setRedirectBanner(null), 5000);
      }
    }
  }, [partner, loadingDishes, channels, orderMode, visibleModeTabs, t]);

  const visibleDishes = useMemo(() => {
    return dishesForPartner.filter((dish) => isDishEnabledForMode(dish, orderMode));
  }, [dishesForPartner, orderMode]);

  const sortedCategoriesAll = useMemo(() => sortCategoriesStable(categoriesForPartner), [categoriesForPartner]);

  const visibleCategoryIds = useMemo(() => {
    return getVisibleCategoryIds({
      categories: sortedCategoriesAll,
      dishes: visibleDishes,
      mode: orderMode,
      includeDisabledCategories: false,
    });
  }, [sortedCategoriesAll, visibleDishes, orderMode]);

  const sortedCategories = useMemo(() => {
    return sortedCategoriesAll.filter((c) => visibleCategoryIds.includes(c.id));
  }, [sortedCategoriesAll, visibleCategoryIds]);

  const groupedDishes = useMemo(() => {
    const dishesByCategory = buildDishesByCategory({
      categories: sortedCategoriesAll,
      dishes: visibleDishes,
      mode: orderMode,
      includeDisabledCategories: false,
    });

    const groups = {};
    for (const [catId, dishList] of dishesByCategory.entries()) {
      if (catId === "__uncat__") {
        if (dishList.length > 0) groups["no-category"] = dishList;
      } else {
        if (dishList.length > 0) groups[catId] = dishList;
      }
    }

    return groups;
  }, [sortedCategoriesAll, visibleDishes, orderMode]);

  const cartTotalItems = cart.reduce((acc, item) => acc + item.quantity, 0);
  const cartTotalAmount = cart.reduce((acc, item) => acc + item.price * item.quantity, 0);

  // Loyalty hook
  const {
    customerEmail,
    setCustomerEmail,
    loyaltyAccount,
    setLoyaltyAccount,
    loyaltyLoading,
    redeemedPoints,
    setRedeemedPoints,
    discountAmount,
    pointsDiscountAmount,
    finalTotal,
    earnedPoints,
    maxRedeemPoints,
  } = useLoyalty({ partner, cartTotalAmount });

  // Loyalty visibility flags
  const loyaltyEnabled = partner?.loyalty_enabled === true;
  const discountEnabled = partner?.discount_enabled === true;
  const showLoyaltySection = (loyaltyEnabled || discountEnabled) && cart.length > 0;

  // TableSession hook
  const {
    tableSession,
    setTableSession,
    currentGuest,
    setCurrentGuest,
    sessionOrders,
    setSessionOrders,
    sessionGuests,
    setSessionGuests,
    sessionItems,
    setSessionItems,
    itemsByOrder,
    billsByGuest,
    myBill,
    myOrders,
    otherGuestsBills,
    othersTotal,
    tableTotal,
    stagesMap,
    getOrderStatus,
    saveGuestId,
    sessionIdRef,
    currentGuestIdRef,
  } = useTableSession({
    partner,
    isHallMode,
    isTableVerified,
    currentTableId,
    orderStages,
    cartTotalAmount,
    getLinkId,
    isRateLimitError,
    t,
  });

  // Reviews hook
  const {
    reviewedItems,
    draftRatings,
    updateDraftRating,
    reviewableItems,
    otherGuestsReviewableItems,
    openReviewDialog,
    reviewDialogOpen,
    setReviewDialogOpen,
    reviewingItems,
    ratings,
    setRatings,
    submittingReview,
    handleSubmitReviews,
  } = useReviews({
    partner,
    currentTableId,
    currentGuest,
    myOrders,
    sessionOrders,
    itemsByOrder,
    stagesMap,
    getLinkId,
    loyaltyAccount,
    setLoyaltyAccount,
    toast,
    t,
  });

  // Rating-first flow (TASK-260130-09-FIX4): show prompt after first draft rating
  // MOVED HERE after useReviews to avoid TDZ (draftRatings, reviewableItems must exist)
  const hasAnyDraftRating = !!draftRatings && Object.keys(draftRatings).length > 0;
  const showRatingBlock = reviewableItems?.length > 0;
  const showLoginPromptAfterRating = loyaltyEnabled && !loyaltyAccount && showRatingBlock && hasAnyDraftRating;

  // Handle instant dish rating (save on star click)
  const handleRateDish = async ({ itemId, dishId, orderId, rating }) => {
    if (!dishId || !rating || ratingSavingByItemId[itemId]) return;
    
    setRatingSavingByItemId(prev => ({ ...prev, [itemId]: true }));
    
    try {
      await base44.entities.DishFeedback.create({
        partner: partner.id,
        dish: dishId,
        order: orderId,
        rating: rating,
        reviewed_by: currentGuest?.id || 'guest',
        order_item: itemId,
        guest: currentGuest?.id,
        author_type: loyaltyAccount ? 'loyalty' : 'anonymous',
        loyalty_account: loyaltyAccount?.id || undefined,
        points_awarded: 0,
      });
      
      toast.success(t('review.thanks') || 'Ð¡Ð¿Ð°ÑÐ¸Ð±Ð¾ Ð·Ð° Ð¾Ñ†ÐµÐ½ÐºÑƒ!', { id: 'mm1' });
      
      // Track that user has rated in this session
      setHasRatedInSession(true);
      
      // Refresh ratings
      queryClient.invalidateQueries({ queryKey: ["dishFeedbacksRecent", partnerId] });
      
    } catch (err) {
      console.error('Failed to save rating:', err);
      toast.error(t('error.save_failed') || 'ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ñ', { id: 'mm1' });
    } finally {
      setRatingSavingByItemId(prev => ({ ...prev, [itemId]: false }));
    }
  };

  // Show cart button in hall mode: always when table verified, or when cart has items (even before verification)
  // TASK-260201-01: StickyBar Ð²Ð¸Ð´ÐµÐ½ Ð’Ð¡Ð•Ð“Ð”Ð Ð¿Ñ€Ð¸ Ð²ÐµÑ€Ð¸Ñ„Ð¸Ñ†Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ð¾Ð¼ ÑÑ‚Ð¾Ð»Ðµ
  // Ð­Ñ‚Ð¾ Ñ€ÐµÑˆÐ°ÐµÑ‚ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ñƒ F5 â€” Ð½Ðµ Ð½ÑƒÐ¶Ð½Ð¾ Ð¶Ð´Ð°Ñ‚ÑŒ Ð²Ð¾ÑÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ñ session/orders
  const showCartButton = isHallMode && (isTableVerified || (cart?.length || 0) > 0);

  // Hall StickyBar mode: Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»ÑÐµÐ¼ Ñ‡Ñ‚Ð¾ Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°Ñ‚ÑŒ
  const hallStickyMode = 
    (cart?.length || 0) > 0 
      ? "cart" 
      : (myOrders?.length || 0) > 0 
        ? "myBill" 
        : (sessionOrders?.length || 0) > 0 
          ? "tableOrders" 
          : "cartEmpty";

  // Hall StickyBar label: Ñ‚ÐµÐºÑÑ‚ ÐºÐ½Ð¾Ð¿ÐºÐ¸
  const hallStickyButtonLabel = 
    hallStickyMode === "cart" 
      ? t("cart.checkout") 
      : hallStickyMode === "myBill" 
        ? (t("cart.my_bill") || "ÐœÐ¾Ð¹ ÑÑ‡Ñ‘Ñ‚") 
        : hallStickyMode === "tableOrders" 
          ? (t("cart.table_orders") || "Ð—Ð°ÐºÐ°Ð·Ñ‹ ÑÑ‚Ð¾Ð»Ð° â†’") 
          : (t("cart.view") || "ÐžÑ‚ÐºÑ€Ñ‹Ñ‚ÑŒ");

  // Hall StickyBar: Ð·Ð°Ð³Ð¾Ð»Ð¾Ð²Ð¾Ðº (Ð´Ð»Ñ Ñ€ÐµÐ¶Ð¸Ð¼Ð¾Ð² Ð±ÐµÐ· ÐºÐ¾Ñ€Ð·Ð¸Ð½Ñ‹)
  const hallStickyModeLabel = 
    hallStickyMode === "myBill" 
      ? (t("cart.my_bill") || "ðŸ“‹ ÐœÐ¾Ð¹ ÑÑ‡Ñ‘Ñ‚") 
      : hallStickyMode === "tableOrders" 
        ? (t("cart.table_orders") || "ðŸ“‹ Ð—Ð°ÐºÐ°Ð·Ñ‹ ÑÑ‚Ð¾Ð»Ð°") 
        : (t("cart.your_orders") || "Ð’Ð°ÑˆÐ¸ Ð·Ð°ÐºÐ°Ð·Ñ‹");

  // Hall StickyBar: ÑÑƒÐ¼Ð¼Ð° Ð´Ð»Ñ Ð¿Ð¾ÐºÐ°Ð·Ð°
  const hallStickyBillTotal = 
    hallStickyMode === "myBill" 
      ? formatPrice(myBill.total) 
      : hallStickyMode === "tableOrders" 
        ? formatPrice(tableTotal) 
        : "";

  // Hall StickyBar: Ð¿Ð¾ÐºÐ°Ð·Ñ‹Ð²Ð°Ñ‚ÑŒ Ð»Ð¸ ÑÑƒÐ¼Ð¼Ñƒ
  const hallStickyShowBillAmount = hallStickyMode === "myBill" || hallStickyMode === "tableOrders";

  // Hall StickyBar: loading state
  const hallStickyIsLoadingBill = 
    (hallStickyMode === "myBill" || hallStickyMode === "tableOrders") && 
    (sessionItems.length === 0 && sessionOrders.length > 0);

  // Generate guest code for Hall mode (if enabled)
  useEffect(() => {
    if (!isHallMode || !hallGuestCodeEnabled) return;
    
    try {
      // P2-2: Should be tied to partner, but keeping simple for now
      let code = localStorage.getItem("menu_guest_code");
      if (!code) {
        code = String(Math.floor(1000 + Math.random() * 9000));
        localStorage.setItem("menu_guest_code", code);
      }
      setGuestCode(code);
    } catch (e) {
      console.error("Failed to init guest code", e);
    }
  }, [isHallMode, hallGuestCodeEnabled]);

  // P0-2: Removed legacy table_id/table_slug handling
  // Only explicit table code from URL triggers hall mode verification
  useEffect(() => {
    if (tableCodeParam && orderMode !== "hall") {
      setOrderMode("hall");
    }
  }, [tableCodeParam, orderMode]);

  // Scroll spy
  useEffect(() => {
    if (view !== "menu") return;

    let rafId;
    let ticking = false;

    const onScroll = () => {
      if (ticking) return;
      ticking = true;

      rafId = window.requestAnimationFrame(() => {
        if (isManualScroll.current) {
          ticking = false;
          return;
        }

        if (window.scrollY < 50) {
          setActiveCategoryKey("all");
          ticking = false;
          return;
        }

        let currentActive = "all";
        for (const cat of sortedCategories) {
          const el = sectionRefs.current[cat.id];
          if (!el) continue;
          const rect = el.getBoundingClientRect();
          if (rect.top < SCROLL_SPY_OFFSET_PX) currentActive = cat.id;
        }

        setActiveCategoryKey(currentActive);
        ticking = false;
      });
    };

    window.addEventListener("scroll", onScroll, { passive: true });
    return () => {
      window.removeEventListener("scroll", onScroll);
      if (rafId) cancelAnimationFrame(rafId);
    };
  }, [sortedCategories, view]);

  useEffect(() => {
    if (view !== "menu") return;
    const chip = chipRefs.current[activeCategoryKey];
    if (chip) chip.scrollIntoView({ behavior: "smooth", block: "nearest", inline: "start" });
  }, [activeCategoryKey, view]);

  const handleCategoryClick = (key) => {
    isManualScroll.current = true;
    setActiveCategoryKey(key);

    if (key === "all") listTopRef.current?.scrollIntoView({ behavior: "smooth", block: "start" });
    else sectionRefs.current[key]?.scrollIntoView({ behavior: "smooth", block: "start" });

    setTimeout(() => {
      isManualScroll.current = false;
    }, MANUAL_SCROLL_LOCK_MS);
  };



  const handleModeChange = (mode) => {
    const channel = channels[mode];
    if (!channel?.available) {
      return;
    }

    const normalized = normalizeMode(mode);
    setOrderMode(normalized);

    const url = new URL(window.location.href);
    url.searchParams.set("mode", normalized);
    window.history.replaceState({}, "", url.toString());

    try {
      localStorage.setItem("menu_preview_mode", normalized);
    } catch {}

    setView("menu");
    setErrors({});
    setSubmitError(null);
    setRedirectBanner(null);
  };

  // Cart handlers - P1-8: use translated name
  const addToCart = (dish) => {
    const translatedName = getDishName(dish);
    setCart((prev) => {
      const existing = prev.find((i) => i.dishId === dish.id);
      if (existing) {
        return prev.map((i) => (i.dishId === dish.id ? { ...i, quantity: i.quantity + 1 } : i));
      }
      return [...prev, { 
        dishId: dish.id, 
        name: translatedName, 
        originalName: dish.name,
        price: dish.price, 
        quantity: 1 
      }];
    });
  };

  const updateQuantity = (dishId, delta) => {
    setCart((prev) =>
      prev
        .map((item) => (item.dishId === dishId ? { ...item, quantity: item.quantity + delta } : item))
        .filter((item) => item.quantity > 0)
    );
  };

  const clearCart = () => {
    setCart([]);
    setCustomerEmail('');
    setLoyaltyAccount(null);
    setRedeemedPoints(0);
  };

  // Check bill cooldown on mount
  useEffect(() => {
    if (currentTableId) {
      setBillCooldown(isBillOnCooldown(currentTableId));
    }
  }, [currentTableId]);

  // Debug mode - moved BEFORE early returns to maintain hook order
  const isDebugGuestItems = searchParams.get('debug') === 'guestItems';

  useEffect(() => {
    if (!isDebugGuestItems) return;
    
    console.log('=== GUEST ITEMS DEBUG ===');
    console.log('currentGuest:', currentGuest?.id, currentGuest);
    console.log('sessionGuests count:', sessionGuests.length, sessionGuests.map(g => ({ id: g.id, name: g.name, guest_number: g.guest_number })));
    console.log('sessionOrders count:', sessionOrders.length);
    console.log('sessionItems count:', sessionItems.length);
    console.log('itemsByOrder size:', itemsByOrder.size);
    
    const guestItemsMap = new Map();
    sessionItems.forEach(item => {
      const orderId = getLinkId(item.order);
      const order = sessionOrders.find(o => o.id === orderId);
      const guestId = getLinkId(order?.guest);
      if (!guestItemsMap.has(guestId)) guestItemsMap.set(guestId, []);
      guestItemsMap.get(guestId).push(item);
    });
    
    console.log('Items per guest:', Object.fromEntries(guestItemsMap));
    
    const first10 = sessionItems.slice(0, 10);
    console.log('First 10 items:', first10.map(item => {
      const orderId = getLinkId(item.order);
      const order = sessionOrders.find(o => o.id === orderId);
      const guestId = getLinkId(order?.guest);
      const stageId = typeof order?.stage_id === 'object' 
        ? (order.stage_id?.id ?? order.stage_id?._id) 
        : order?.stage_id;
      const stage = stageId ? stagesMap.get(String(stageId)) : null;
      return {
        itemId: item.id,
        dish: item.dish_name,
        orderId,
        guestId,
        orderStatus: order?.status,
        stageCode: stage?.internal_code,
        visible: guestId === currentGuest?.id ? 'YES' : 'other guest'
      };
    }));
    console.log('=========================');
  }, [isDebugGuestItems, currentGuest?.id, sessionGuests, sessionOrders, sessionItems, itemsByOrder, stagesMap]);

  // P0-7: Removed handleTableSelection - no dropdown

  // Phone input
  const handlePhoneChange = (e) => {
    const val = e.target.value;
    if (!val) {
      setClientPhone("");
      return;
    }
    const hasPlus = val.startsWith("+");
    const digitsOnly = val.replace(/\D/g, "");
    setClientPhone(hasPlus ? "+" + digitsOnly : digitsOnly);
  };

  const handlePhoneFocus = () => {
    if (!clientPhone) setClientPhone("+");
  };

  const validate = () => {
    const newErrors = {};
    const raw = (clientPhone || "").trim();

    const checkPhone = () => {
      if (!/^\+?\d*$/.test(raw)) return t('error.phone_invalid');
      const digitsCount = raw.replace(/\D/g, "").length;
      if (digitsCount < 8) return t('error.phone_short');
      if (digitsCount > 15) return t('error.phone_long');
      return null;
    };

    if (orderMode === "hall") {
      // P0-1: Hall mode - table MUST be verified with real ID
      if (!currentTableId) {
        newErrors.tableSelection = t('error.table_required');
      }
      if (raw) {
        const err = checkPhone();
        if (err) newErrors.clientPhone = err;
      }
    } else {
      if (!clientName.trim()) newErrors.clientName = t('error.name_required');

      if (!raw) newErrors.clientPhone = t('error.phone_required');
      else {
        const err = checkPhone();
        if (err) newErrors.clientPhone = err;
      }

      if (orderMode === "delivery" && !deliveryAddress.trim()) {
        newErrors.deliveryAddress = t('error.address_required');
      }
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  // P1-4: Anti-spam with partner filter
  const checkRateLimit = async () => {
    if (!clientPhone) return true;

    try {
      const recentOrders = await base44.entities.Order.filter({
        partner: partner.id,
        client_phone: clientPhone,
      });
      
      const now = new Date();
      const thresholdMinutes = 15;
      const limitCount = 3;
      const activeStatuses = ["new", "accepted", "in_progress", "ready"]; 

      const recentUserOrders = recentOrders.filter((o) => {
        if (!activeStatuses.includes(o.status)) return false;

        const created = new Date(o.created_date);
        const diffMinutes = (now - created) / 1000 / 60;
        return diffMinutes <= thresholdMinutes;
      });

      return recentUserOrders.length < limitCount;
    } catch (e) {
      console.error("Rate limit check failed", e);
      return true;
    }
  };



  // Submit order
  // Process hall order
  const processHallOrder = async (guestToUse) => {
    try {
      // Handle loyalty account (find or create if email provided)
      let loyaltyAccountToUse = loyaltyAccount;
      if (customerEmail && customerEmail.trim() && !loyaltyAccountToUse) {
        const emailLower = customerEmail.trim().toLowerCase();
        const existingAccounts = await base44.entities.LoyaltyAccount.filter({
          partner: partner.id,
          email: emailLower
        });
        
        if (existingAccounts && existingAccounts.length > 0) {
          loyaltyAccountToUse = existingAccounts[0];
        } else if (loyaltyEnabled) {
          loyaltyAccountToUse = await base44.entities.LoyaltyAccount.create({
            partner: partner.id,
            email: emailLower,
            balance: 0,
            total_earned: 0,
            total_spent: 0,
            total_expired: 0,
            visit_count: 0
          });
        }
      }

      // Validate points redemption
      if (redeemedPoints > 0) {
        if (!loyaltyAccountToUse || loyaltyAccountToUse.balance < redeemedPoints) {
          toast.error(t('loyalty.insufficient_points'), { id: 'mm1' });
          return false;
        }
      }

      // Process points redemption BEFORE creating order
      if (loyaltyAccountToUse && redeemedPoints > 0) {
        await base44.entities.LoyaltyTransaction.create({
          account: loyaltyAccountToUse.id,
          type: 'redeem',
          amount: -redeemedPoints,
          description: t('loyalty.transaction.redeem')
        });
        
        await base44.entities.LoyaltyAccount.update(loyaltyAccountToUse.id, {
          balance: loyaltyAccountToUse.balance - redeemedPoints,
          total_spent: (loyaltyAccountToUse.total_spent || 0) + redeemedPoints
        });
      }

      // Get start stage for this order type
      const startStage = getStartStage(orderStages, orderMode);
      
      // Generate order number (for staff, not shown to guest)
      const { orderNumber, updatedCounters } = getNextOrderNumber(partner, 'hall');

      const orderData = {
        partner: partner.id,
        order_type: 'hall',
        status: "new",
        stage_id: startStage?.id || null,
        payment_status: "unpaid",
        total_amount: finalTotal,
        comment: comment || undefined,
        client_phone: clientPhone || undefined,
        client_email: customerEmail && customerEmail.trim() ? customerEmail.trim().toLowerCase() : undefined,
        public_token: Math.random().toString(36).substring(7),
        table: currentTableId,
        table_session: tableSession?.id || null,
        guest: guestToUse?.id || null,
        order_number: orderNumber,
        loyalty_account: loyaltyAccountToUse?.id || null,
        points_redeemed: redeemedPoints || 0,
        discount_amount: discountAmount + pointsDiscountAmount,
      };

      if (partner?.id && orderData.table) saveTableSelection(partner.id, orderData.table);

      const order = await base44.entities.Order.create(orderData);

      // Create order items with split_type
      const newItems = cart.map((item) => ({
        order: order.id,
        dish: item.dishId,
        dish_name: item.name,
        dish_price: item.price,
        quantity: item.quantity,
        line_total: item.price * item.quantity,
        split_type: splitType,
      }));

      await base44.entities.OrderItem.bulkCreate(newItems);

      // Earn points after order creation
      if (loyaltyAccountToUse && loyaltyEnabled && earnedPoints > 0) {
        const expiresAt = new Date();
        expiresAt.setDate(expiresAt.getDate() + (partner.loyalty_expiry_days || 100));
        
        await base44.entities.LoyaltyTransaction.create({
          account: loyaltyAccountToUse.id,
          type: 'earn_order',
          amount: earnedPoints,
          order: order.id,
          description: t('loyalty.transaction.earn_order', { orderNumber: order.order_number }),
          expires_at: expiresAt.toISOString()
        });
        
        const newBalance = (loyaltyAccountToUse.balance - redeemedPoints) + earnedPoints;
        await base44.entities.LoyaltyAccount.update(loyaltyAccountToUse.id, {
          balance: newBalance,
          total_earned: (loyaltyAccountToUse.total_earned || 0) + earnedPoints,
          visit_count: (loyaltyAccountToUse.visit_count || 0) + 1,
          last_visit_at: new Date().toISOString()
        });
        
        await base44.entities.Order.update(order.id, {
          points_earned: earnedPoints
        });
      }

      // Update partner counters
      await base44.entities.Partner.update(partner.id, updatedCounters);
      
      // Update local partner cache
      queryClient.setQueryData(["publicPartner", partnerParamRaw], (prev) =>
        prev ? { ...prev, ...updatedCounters } : prev
      );

      // Optimistic update session data with proper guest link
      const orderWithGuest = { 
        ...order, 
        guest: guestToUse?.id 
      };
      setSessionOrders(prev => [orderWithGuest, ...prev]);
      
      const tempIdBase = typeof crypto !== 'undefined' && crypto.randomUUID 
        ? crypto.randomUUID() 
        : `${Date.now()}_${Math.random().toString(16).slice(2)}`;
      
      const itemsWithLinks = newItems.map((item, i) => ({ 
        ...item, 
        id: `temp_${tempIdBase}_${i}`,
        order: order.id 
      }));
      
      setSessionItems(prev => [...prev, ...itemsWithLinks]);

      // Clear form
      clearCart();
      clearCartStorage(partner.id);
      setSplitType('single');
      setComment("");
      setCustomerEmail('');
      setLoyaltyAccount(null);
      setRedeemedPoints(0);

      // Stay on menu with cart drawer open to show the order
      setView("menu");
      
      toast.success(t('toast.order_sent'), { id: 'mm1' });

      console.log("Order created", order?.id);
      return true;
    } catch (err) {
      console.error(err);
      setSubmitError(t('error.submit_failed'));
      return false;
    }
  };

  const handleSubmitOrder = async () => {
    // CODE-024: protect from double-tap
    if (submitLockRef.current) return;
    
    if (!validate()) return;
    
    // Empty cart guard
    if (cart.length === 0) {
      toast.error(t('cart.empty'), { id: 'mm1' });
      return;
    }

    // P0-1: Extra safety check for hall mode
    if (orderMode === "hall" && !currentTableId) {
      setSubmitError(t('error.table_required'));
      return;
    }

    submitLockRef.current = true;
    setIsSubmitting(true);
    setSubmitError(null);

    try {
      // Hall mode: handle session and guest
      if (orderMode === "hall" && isTableVerified) {
        // Ensure we have a session
        let session = tableSession;
        if (!session) {
          session = await getOrCreateSession(partner.id, currentTableId);
          setTableSession(session);
          sessionIdRef.current = session?.id;
        }

        // ============================================================
        // FIX-260131-07 FINAL: SAFEGUARD â€” try restore guest before creating new
        // This prevents "submit races restore" bug where guest is created
        // because currentGuest hasn't been set yet
        // ============================================================
        let guest = currentGuest;

        if (!guest) {
          try {
            const normalizeId = (g) => String(g?.id ?? g?._id ?? "");
            
            // 1) Try device-based lookup (all known device keys)
            const deviceIds = Array.from(new Set(
              [getDeviceId(), localStorage.getItem("menu_device_id"), localStorage.getItem("menuapp_device_id")]
                .filter(Boolean)
                .map(String)
            ));

            for (const dId of deviceIds) {
              if (guest) break;
              const found = await findGuestByDevice(session.id, dId);
              if (found) { guest = found; }
            }

            // 2) Try saved guestId from localStorage (ALL keys, not || )
            if (!guest) {
              const TTL_MS = 8 * 60 * 60 * 1000;
              const readGuestId = (key) => {
                try {
                  const raw = localStorage.getItem(key);
                  if (!raw) return null;
                  const data = JSON.parse(raw);
                  const ts = data?.ts ?? data?.timestamp;
                  const gid = data?.guestId;
                  if (!gid) return null;
                  if (ts && (Date.now() - ts > TTL_MS)) return null;
                  return String(gid);
                } catch { return null; }
              };

              // All possible keys
              const sessionKey = `menuApp_hall_guest_${partner.id}_${session.id}`;
              const tableKey = `menuApp_hall_guest_${partner.id}_${currentTableId}`;
              const legacyKey = `menuapp_guest_${partner.id}_${currentTableId}`;
              
              const sessionSavedId = readGuestId(sessionKey);
              const tableSavedId = readGuestId(tableKey);
              const legacySavedId = readGuestId(legacyKey);

              // Load guests ONCE (optimization)
              const guests = await getSessionGuests(session.id);

              // Try session-key first
              if (sessionSavedId) {
                guest = (guests || []).find(g => normalizeId(g) === sessionSavedId) || null;
              }
              // If not found, try table-key
              if (!guest && tableSavedId) {
                guest = (guests || []).find(g => normalizeId(g) === tableSavedId) || null;
              }
              // If not found, try legacy-key
              if (!guest && legacySavedId) {
                guest = (guests || []).find(g => normalizeId(g) === legacySavedId) || null;
              }
              
              // 3) Try guest_code lookup (using already loaded guests)
              if (!guest) {
                const guestCode = localStorage.getItem("menu_guest_code");
                if (guestCode) {
                  guest = (guests || []).find(g => {
                    const code = g?.guest_code ?? g?.guestCode ?? g?.code ?? g?.menu_guest_code;
                    return code != null && String(code) === String(guestCode);
                  }) || null;
                }
              }
            }

            // If restored â†’ sync state + storage
            if (guest) {
              const gid = normalizeId(guest);
              setCurrentGuest(guest);
              currentGuestIdRef.current = gid || null;
              if (gid) {
                saveGuestId(partner.id, session.id, currentTableId, gid);
              }
              setSessionGuests(prev => {
                const list = Array.isArray(prev) ? prev : [];
                return (gid && list.some(x => normalizeId(x) === gid)) ? list : [...list, guest];
              });
            }
          } catch (e) {
            // Ignore errors, will create new guest below
          }
        }

        // If still no guest after safeguard â€” create new
        if (!guest) {
          const deviceId = getDeviceId();
          guest = await addGuestToSession(session.id, null, deviceId);
          const gid = String(guest?.id ?? guest?._id ?? "");
          setCurrentGuest(guest);
          currentGuestIdRef.current = gid || null;
          setSessionGuests(prev => [...(Array.isArray(prev) ? prev : []), guest]);
          // Save guest ID for persistence across refreshes
          if (gid) {
            saveGuestId(partner.id, session.id, currentTableId, gid);
          }
        }
        // ============================================================
        // END FIX-260131-07 FINAL
        // ============================================================

        // Process the order
        const success = await processHallOrder(guest);
        if (!success) {
          submitLockRef.current = false;
          setIsSubmitting(false);
          return;
        }
      } else {
        // Pickup/Delivery flow (unchanged)
        if (orderMode === "pickup" || orderMode === "delivery" || clientPhone) {
          const isAllowed = await checkRateLimit();
          if (!isAllowed) {
            setSubmitError(t('error.rate_limit'));
            submitLockRef.current = false;
            setIsSubmitting(false);
            return;
          }
        }

        // Handle loyalty account (find or create if email provided)
        let loyaltyAccountToUse = loyaltyAccount;
        if (customerEmail && customerEmail.trim() && !loyaltyAccountToUse) {
          const emailLower = customerEmail.trim().toLowerCase();
          const existingAccounts = await base44.entities.LoyaltyAccount.filter({
            partner: partner.id,
            email: emailLower
          });
          
          if (existingAccounts && existingAccounts.length > 0) {
            loyaltyAccountToUse = existingAccounts[0];
          } else if (loyaltyEnabled) {
            loyaltyAccountToUse = await base44.entities.LoyaltyAccount.create({
              partner: partner.id,
              email: emailLower,
              balance: 0,
              total_earned: 0,
              total_spent: 0,
              total_expired: 0,
              visit_count: 0
            });
          }
        }

        // Validate points redemption
        if (redeemedPoints > 0) {
          if (!loyaltyAccountToUse || loyaltyAccountToUse.balance < redeemedPoints) {
            toast.error(t('loyalty.insufficient_points'), { id: 'mm1' });
            submitLockRef.current = false;
            setIsSubmitting(false);
            return;
          }
        }

        // Process points redemption BEFORE creating order
        if (loyaltyAccountToUse && redeemedPoints > 0) {
          await base44.entities.LoyaltyTransaction.create({
            account: loyaltyAccountToUse.id,
            type: 'redeem',
            amount: -redeemedPoints,
            description: t('loyalty.transaction.redeem')
          });
          
          await base44.entities.LoyaltyAccount.update(loyaltyAccountToUse.id, {
            balance: loyaltyAccountToUse.balance - redeemedPoints,
            total_spent: (loyaltyAccountToUse.total_spent || 0) + redeemedPoints
          });
        }

        // Get start stage for this order type
        const startStage = getStartStage(orderStages, orderMode);

        const orderData = {
          partner: partner.id,
          order_type: orderMode,
          status: "new",
          stage_id: startStage?.id || null,
          payment_status: "unpaid",
          total_amount: finalTotal,
          comment: comment || undefined,
          client_name: clientName || undefined,
          client_phone: clientPhone || undefined,
          client_email: customerEmail && customerEmail.trim() ? customerEmail.trim().toLowerCase() : undefined,
          delivery_address: orderMode === "delivery" ? deliveryAddress || undefined : undefined,
          public_token: Math.random().toString(36).substring(7),
          loyalty_account: loyaltyAccountToUse?.id || null,
          points_redeemed: redeemedPoints || 0,
          discount_amount: discountAmount + pointsDiscountAmount,
        };

        const order = await base44.entities.Order.create(orderData);

        const orderItemsData = cart.map((item) => ({
          order: order.id,
          dish: item.dishId,
          dish_name: item.name,
          dish_price: item.price,
          quantity: item.quantity,
          line_total: item.price * item.quantity,
        }));

        await base44.entities.OrderItem.bulkCreate(orderItemsData);

        // Earn points after order creation
        if (loyaltyAccountToUse && loyaltyEnabled && earnedPoints > 0) {
          const expiresAt = new Date();
          expiresAt.setDate(expiresAt.getDate() + (partner.loyalty_expiry_days || 100));
          
          await base44.entities.LoyaltyTransaction.create({
            account: loyaltyAccountToUse.id,
            type: 'earn_order',
            amount: earnedPoints,
            order: order.id,
            description: t('loyalty.transaction.earn_order', { orderNumber: order.order_number || order.id }),
            expires_at: expiresAt.toISOString()
          });
          
          const newBalance = (loyaltyAccountToUse.balance - redeemedPoints) + earnedPoints;
          await base44.entities.LoyaltyAccount.update(loyaltyAccountToUse.id, {
            balance: newBalance,
            total_earned: (loyaltyAccountToUse.total_earned || 0) + earnedPoints,
            visit_count: (loyaltyAccountToUse.visit_count || 0) + 1,
            last_visit_at: new Date().toISOString()
          });
          
          await base44.entities.Order.update(order.id, {
            points_earned: earnedPoints
          });
        }

        clearCart();
        clearCartStorage(partner.id);
        setClientName("");
        setClientPhone("");
        setDeliveryAddress("");
        setComment("");
        setCustomerEmail('');
        setLoyaltyAccount(null);
        setRedeemedPoints(0);

        setView("menu");
        setDrawerMode(null); // Close drawer after successful order
        
        toast.success(t('toast.order_sent'), { id: 'mm1' });

        console.log("Order created", order?.id);
      }
    } catch (err) {
      console.error(err);
      setSubmitError(t('error.submit_failed'));
    } finally {
      submitLockRef.current = false;
      setIsSubmitting(false);
    }
  };

  // Update guest name (inline on cart page)
  const handleUpdateGuestName = async () => {
    if (!currentGuest?.id || !guestNameInput.trim()) return;
    
    try {
      await base44.entities.SessionGuest.update(currentGuest.id, {
        name: guestNameInput.trim()
      });
      
      setCurrentGuest(prev => ({ ...prev, name: guestNameInput.trim() }));
      setSessionGuests(prev => prev.map(g => 
        g.id === currentGuest.id ? { ...g, name: guestNameInput.trim() } : g
      ));
      setIsEditingName(false);
      setGuestNameInput('');
      
      toast.success(t('guest.name_saved'), { id: 'mm1' });
    } catch (err) {
      console.error('Failed to update guest name:', err);
      toast.error(t('error.save_failed'), { id: 'mm1' });
    }
  };

  // Request bill (ServiceRequest)
  const handleCheckoutClick = () => {
    setView("checkout");
  };

  const handleRequestBill = async () => {
    if (billCooldown || billRequested) {
      toast.info(t('cart.bill_already_requested') || 'Ð¡Ñ‡Ñ‘Ñ‚ ÑƒÐ¶Ðµ Ð·Ð°Ð¿Ñ€Ð¾ÑˆÐµÐ½', { id: 'mm1' });
      return;
    }
    
    setBillRequested(true);
    try {
      await base44.entities.ServiceRequest.create({
        partner: partner.id,
        table: currentTableId,
        table_session: tableSession?.id,
        request_type: 'bill',
        status: 'new',
        source: 'public'
      });
      
      setBillCooldownStorage(currentTableId);
      setBillCooldown(true);
      toast.success(t('cart.bill_requested') || 'ÐžÑ„Ð¸Ñ†Ð¸Ð°Ð½Ñ‚ ÑÐºÐ¾Ñ€Ð¾ Ð¿Ñ€Ð¸Ð½ÐµÑÑ‘Ñ‚ ÑÑ‡Ñ‘Ñ‚', { id: 'mm1' });
    } catch (err) {
      console.error('Failed to request bill:', err);
      toast.error(t('toast.error') || 'ÐžÑˆÐ¸Ð±ÐºÐ°', { id: 'mm1' });
      setBillRequested(false);
    }
  };



  // Guards
  if (!partnerParamRaw) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-slate-50 p-4">
        <Card className="w-full max-w-md text-center p-6">
          <p className="text-slate-700 font-medium">{t('error.partner_missing')}</p>
          <p className="text-slate-500 text-sm mt-2">
            {t('error.partner_hint')} <span className="font-mono">?partner=&lt;partner_id|slug&gt;</span>
          </p>
        </Card>
      </div>
    );
  }

  if (loadingPartner) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-slate-50">
        <Loader2 className="w-8 h-8 animate-spin text-indigo-600" />
      </div>
    );
  }

  if (!partner) {
    return (
      <div className="min-h-screen flex items-center justify-center bg-slate-50 p-4">
        <Card className="w-full max-w-md text-center p-6">
          <p className="text-slate-500">{t('error.partner_not_found')}</p>
        </Card>
      </div>
    );
  }

  // P1-5: Error UI for failed requests
  if ((dishesError || categoriesError) && !isRateLimitError(dishesError) && !isRateLimitError(categoriesError)) {
    return (
      <ErrorState
        onRetry={() => window.location.reload()}
        t={t}
      />
    );
  }

  // Empty state: no content at all
  if (!loadingDishes && !channels.hasAnyContent) {
    return (
      <EmptyMenuState
        partner={partner}
        activeContactLinks={activeContactLinks}
        viewMode={viewMode}
        enabledLanguages={enabledLanguages}
        enabledCurrencies={enabledCurrencies}
        lang={lang}
        activeCurrency={activeCurrency}
        onLangChange={handleLangChange}
        onCurrencyChange={handleCurrencyChange}
        onContactClick={handleContactClick}
        isSafeUrl={isSafeUrl}
        t={t}
        CURRENCY_SYMBOLS={CURRENCY_SYMBOLS}
      />
    );
  }

  const getModeDescription = () => {
    switch (orderMode) {
      case "hall":
        return t('mode.hall.desc');
      case "pickup":
        return t('mode.pickup.desc');
      case "delivery":
        return t('mode.delivery.desc');
      default:
        return "";
    }
  };

  // ============================================================
  // HALL CHECKOUT SCREEN (TASK-260127-01: removed "Ð¡Ñ‚Ð¾Ð» Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶Ð´Ñ‘Ð½" block)
  // ============================================================
  const renderHallCheckoutContent = () => {
    // Table already verified - nothing special needed here
    // (table info shown in menu header, comment field below)
    if (isTableVerified && currentTableId) {
      return null;
    }

    // Table NOT verified - show verification options (NO dropdown per P0-7)
    const showHallOnlineBenefitsHint = !!(partner?.discount_enabled || partner?.loyalty_enabled);

    return (
      <div className="space-y-3">
        <div className="text-sm text-slate-700 text-center">
          {t('hall.verify.title') || 'Ð§Ñ‚Ð¾Ð±Ñ‹ Ð¾Ñ„Ð¸Ñ†Ð¸Ð°Ð½Ñ‚ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ð» Ð·Ð°ÐºÐ°Ð· ÑÑ€Ð°Ð·Ñƒ'}
        </div>
        <div className="text-xs text-slate-500 text-center">
          {t('hall.verify.subtitle') || 'Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ ÐºÐ¾Ð´ ÑÐ¾ ÑÑ‚Ð¾Ð»Ð° Ð¸Ð»Ð¸ Ð½Ð°Ð·Ð¾Ð²Ð¸Ñ‚Ðµ ÐµÐ³Ð¾ Ð¾Ñ„Ð¸Ñ†Ð¸Ð°Ð½Ñ‚Ñƒ'}
        </div>
        <div className="text-xs text-slate-500 text-center">
          {t('hall.verify.benefit') || 'ÐŸÐ¾ÑÐ»Ðµ ÑÑ‚Ð¾Ð³Ð¾ Ð·Ð°ÐºÐ°Ð·Ñ‹ Ð±ÑƒÐ´ÑƒÑ‚ Ð¿Ñ€Ð¸Ñ…Ð¾Ð´Ð¸Ñ‚ÑŒ Ð¾Ñ„Ð¸Ñ†Ð¸Ð°Ð½Ñ‚Ñƒ Ð½Ð°Ð¿Ñ€ÑÐ¼ÑƒÑŽ'}
        </div>

        <HallVerifyBlock
          tableCodeInput={tableCodeInput}
          setTableCodeInput={setTableCodeInput}
          isVerifyingCode={isVerifyingCode}
          codeVerificationError={codeVerificationError}
          hallGuestCodeEnabled={hallGuestCodeEnabled}
          guestCode={guestCode}
          partner={partner}
          t={t}
        />

        {showHallOnlineBenefitsHint && (
          <div className="text-xs text-slate-500 text-center">
            {t('hall.verify.online_benefits') || 'ðŸŽ Ð‘Ð¾Ð½ÑƒÑÑ‹ Ð¸ ÑÐºÐ¸Ð´ÐºÐ¸ Ð·Ð° Ð¾Ð½Ð»Ð°Ð¹Ð½-Ð·Ð°ÐºÐ°Ð·Ñ‹'}
          </div>
        )}
      </div>
    );
};

  return (
    <div className="min-h-screen bg-slate-50 pb-24 font-sans">
      <PublicMenuHeader
        partner={partner}
        activeContactLinks={activeContactLinks}
        viewMode={viewMode}
        enabledLanguages={enabledLanguages}
        enabledCurrencies={enabledCurrencies}
        lang={lang}
        activeCurrency={activeCurrency}
        onLangChange={handleLangChange}
        onCurrencyChange={handleCurrencyChange}
        onContactClick={handleContactClick}
        isSafeUrl={isSafeUrl}
        t={t}
        CURRENCY_SYMBOLS={CURRENCY_SYMBOLS}
      />

      {/* Redirect banner */}
      {redirectBanner && (
        <RedirectBanner
          redirectBanner={redirectBanner}
          onClose={() => setRedirectBanner(null)}
          t={t}
        />
      )}

      {/* Mode tabs */}
      {view === "menu" && visibleModeTabs.length > 0 && (
        <ModeTabs
          visibleModeTabs={visibleModeTabs}
          orderMode={orderMode}
          onModeChange={handleModeChange}
          getModeDescription={getModeDescription}
          isHallMode={isHallMode}
          isTableVerified={isTableVerified}
          currentTableId={currentTableId}
          currentTable={currentTable}
          tableCodeParam={tableCodeParam}
          resolvedTable={resolvedTable}
          verifiedByCode={verifiedByCode}
          t={t}
        />
      )}

      {/* Category chips */}
      {view === "menu" && sortedCategories.length > 1 && (
        <CategoryChips
          sortedCategories={sortedCategories}
          activeCategoryKey={activeCategoryKey}
          onCategoryClick={handleCategoryClick}
          getCategoryName={getCategoryName}
          chipRefs={chipRefs}
          t={t}
        />
      )}

      {/* Menu list */}
      {view === "menu" && (
        <MenuView
          partner={partner}
          isMobile={isMobile}
          mobileLayout={mobileLayout}
          onSetMobileLayout={handleSetMobileLayout}
          showReviews={showReviews}
          dishRatings={dishRatings}
          onOpenReviews={(dishId) => setSelectedDishId(dishId)}
          listTopRef={listTopRef}
          loadingDishes={loadingDishes}
          sortedCategories={sortedCategories}
          groupedDishes={groupedDishes}
          getCategoryName={getCategoryName}
          sectionRefs={sectionRefs}
          cart={cart}
          getDishName={getDishName}
          getDishDescription={getDishDescription}
          formatPrice={formatPrice}
          addToCart={addToCart}
          updateQuantity={updateQuantity}
          t={t}
        />
      )}

      {/* Checkout */}
      {view === "checkout" && (
        <CheckoutView
          t={t}
          setView={setView}
          cart={cart}
          updateQuantity={updateQuantity}
          formatPrice={formatPrice}
          cartTotalItems={cartTotalItems}
          cartTotalAmount={cartTotalAmount}
          clearCart={clearCart}
          showLoyaltySection={showLoyaltySection}
          customerEmail={customerEmail}
          setCustomerEmail={setCustomerEmail}
          loyaltyLoading={loyaltyLoading}
          loyaltyAccount={loyaltyAccount}
          partner={partner}
          earnedPoints={earnedPoints}
          redeemedPoints={redeemedPoints}
          setRedeemedPoints={setRedeemedPoints}
          maxRedeemPoints={maxRedeemPoints}
          discountEnabled={discountEnabled}
          discountAmount={discountAmount}
          pointsDiscountAmount={pointsDiscountAmount}
          finalTotal={finalTotal}
          loyaltyEnabled={loyaltyEnabled}
          activeCurrency={activeCurrency}
          defaultCurrency={defaultCurrency}
          orderMode={orderMode}
          renderHallCheckoutContent={renderHallCheckoutContent}
          clientName={clientName}
          setClientName={setClientName}
          clientPhone={clientPhone}
          handlePhoneChange={handlePhoneChange}
          handlePhoneFocus={handlePhoneFocus}
          deliveryAddress={deliveryAddress}
          setDeliveryAddress={setDeliveryAddress}
          comment={comment}
          setComment={setComment}
          errors={errors}
          submitError={submitError}
          isSubmitting={isSubmitting}
          handleSubmitOrder={handleSubmitOrder}
          isTableVerified={isTableVerified}
          currentTableId={currentTableId}
        />
      )}

      {/* TASK-260203-01: Cart as Bottom Drawer */}
      <Drawer 
        open={drawerMode === 'cart'} 
        onOpenChange={(open) => !open && setDrawerMode(null)}
      >
        <DrawerContent className="max-h-[85vh] overflow-hidden">
          <DrawerHeader className="sr-only">
            <DrawerTitle>ÐšÐ¾Ñ€Ð·Ð¸Ð½Ð°</DrawerTitle>
          </DrawerHeader>
          <div className="overflow-y-auto max-h-[calc(85vh-2rem)]">
            <CartView
              partner={partner}
              currentTable={currentTable}
              currentGuest={currentGuest}
              t={t}
              setView={setView}
              isEditingName={isEditingName}
              guestNameInput={guestNameInput}
              setGuestNameInput={setGuestNameInput}
              handleUpdateGuestName={handleUpdateGuestName}
              setIsEditingName={setIsEditingName}
              getGuestDisplayName={getGuestDisplayName}
              cart={cart}
              formatPrice={formatPrice}
              updateQuantity={updateQuantity}
              sessionGuests={sessionGuests}
              splitType={splitType}
              setSplitType={setSplitType}
              showLoyaltySection={showLoyaltySection}
              showLoginPromptAfterRating={showLoginPromptAfterRating}
              customerEmail={customerEmail}
              setCustomerEmail={setCustomerEmail}
              loyaltyLoading={loyaltyLoading}
              loyaltyAccount={loyaltyAccount}
              earnedPoints={earnedPoints}
              maxRedeemPoints={maxRedeemPoints}
              redeemedPoints={redeemedPoints}
              setRedeemedPoints={setRedeemedPoints}
              toast={toast}
              cartTotalAmount={cartTotalAmount}
              discountAmount={discountAmount}
              pointsDiscountAmount={pointsDiscountAmount}
              isSubmitting={isSubmitting}
              handleSubmitOrder={handleSubmitOrder}
              myOrders={myOrders}
              itemsByOrder={itemsByOrder}
              getOrderStatus={getOrderStatus}
              reviewedItems={reviewedItems}
              draftRatings={draftRatings}
              updateDraftRating={updateDraftRating}
              sessionItems={sessionItems}
              sessionOrders={sessionOrders}
              myBill={myBill}
              reviewableItems={reviewableItems}
              openReviewDialog={openReviewDialog}
              handleRequestBill={handleRequestBill}
              billRequested={billRequested}
              billCooldown={billCooldown}
              otherGuestsBills={otherGuestsBills}
              othersTotal={othersTotal}
              setOtherGuestsExpanded={setOtherGuestsExpanded}
              otherGuestsExpanded={otherGuestsExpanded}
              getLinkId={getLinkId}
              otherGuestsReviewableItems={otherGuestsReviewableItems}
              tableTotal={tableTotal}
              formatOrderTime={formatOrderTime}
              handleRateDish={handleRateDish}
              ratingSavingByItemId={ratingSavingByItemId}
              onClose={() => setDrawerMode(null)}
              onCallWaiter={handleOpenHelpModal}
              isTableVerified={isTableVerified}
              tableCodeInput={tableCodeInput}
              setTableCodeInput={setTableCodeInput}
              isVerifyingCode={isVerifyingCode}
              verifyTableCode={verifyTableCode}
              codeVerificationError={codeVerificationError}
              hallGuestCodeEnabled={hallGuestCodeEnabled}
              guestCode={guestCode}
            />
          </div>
        </DrawerContent>
      </Drawer>

      {/* Floating Help Button - only when table verified in Hall */}
      {orderMode === "hall" && isTableVerified && currentTableId && (
        <HelpFab
          fabSuccess={fabSuccess}
          isSendingHelp={isSendingHelp}
          isHelpModalOpen={isHelpModalOpen}
          onOpen={handleOpenHelpModal}
          t={t}
        />
      )}

      {/* Help Modal */}
      {isHelpModalOpen && (
        <HelpModal
          onClose={() => setIsHelpModalOpen(false)}
          t={t}
          currentTableLabel={currentTable?.name || currentTable?.code || ""}
          hasActiveRequest={hasActiveRequest}
          selectedHelpType={selectedHelpType}
          onSelectHelpType={handlePresetSelect}
          helpComment={helpComment}
          onChangeHelpComment={setHelpComment}
          helpSubmitError={helpSubmitError}
          isSendingHelp={isSendingHelp}
          onSubmit={submitHelpRequest}
          disabled={!currentTableId}
        />
      )}

      {/* P0-6: Removed custom toast - using sonner */}

      {/* Review Dialog */}
      <ReviewDialog
        open={reviewDialogOpen}
        onOpenChange={setReviewDialogOpen}
        t={t}
        partner={partner}
        reviewingItems={reviewingItems}
        ratings={ratings}
        onChangeRating={(itemId, val) => setRatings(prev => ({
          ...prev,
          [itemId]: { ...prev[itemId], rating: val }
        }))}
        onChangeComment={(itemId, text) => setRatings(prev => ({
          ...prev,
          [itemId]: { ...prev[itemId], comment: text }
        }))}
        submittingReview={submittingReview}
        onSubmit={handleSubmitReviews}
        hasLoyalty={!!loyaltyAccount}
      />

      {/* Dish Reviews Modal (read-only) */}
      <DishReviewsModal
        open={!!selectedDishId}
        onOpenChange={(open) => !open && setSelectedDishId(null)}
        dishTitle={selectedDish ? getDishName(selectedDish) : undefined}
        reviews={selectedDishReviews}
        loading={loadingDishReviews}
      />

      {/* Sticky cart bar - updated for TableSession */}
      {view === "menu" && (() => {
        // Hall mode: show if cart has items OR if there are past orders OR table activity
        if (isHallMode && showCartButton) {
          return (
            <StickyCartBar
              t={t}
              isHallMode={true}
              hasCart={(cart?.length || 0) > 0}
              cartTotalItems={cartTotalItems}
              formattedCartTotal={formatPrice(cartTotalAmount)}
              isLoadingBill={hallStickyIsLoadingBill}
              formattedBillTotal={hallStickyBillTotal}
              onButtonClick={() => setDrawerMode(drawerMode === 'cart' ? null : 'cart')}
              buttonLabel={drawerMode === 'cart' ? (t('common.close') || 'Ð—Ð°ÐºÑ€Ñ‹Ñ‚ÑŒ') : hallStickyButtonLabel}
              hallModeLabel={hallStickyModeLabel}
              showBillAmount={hallStickyShowBillAmount}
            />
          );
        }

        // Pickup/Delivery: original behavior
        if (cart.length > 0) {
          return (
            <StickyCartBar
              t={t}
              isHallMode={false}
              hasCart={true}
              cartTotalItems={cartTotalItems}
              formattedCartTotal={formatPrice(cartTotalAmount)}
              isLoadingBill={false}
              formattedBillTotal=""
              onButtonClick={handleCheckoutClick}
              buttonLabel={t('cart.checkout')}
            />
          );
        }

        return null;
      })()}
    </div>
  );
}